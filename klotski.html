<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Klotski</title>
    <style>
        @font-face {
            font-family: 'DSEG7Modern';
            src: url('./DSEG7Modern-BoldItalic.ttf') format('truetype');
            font-weight: bold;
            font-style: italic;
        }
        
        body {
            margin: 0;
            padding: 10px;
            background: #0D1117;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            max-height: 100vh;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
            box-sizing: border-box;
        }
        
        .game-container {
            position: relative;
            width: 420px;
            height: 520px;
            background: #0D1117;
            border: 10px solid #484f58;
            border-radius: 8px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
            margin-top: 20px;
            padding: 10px;
            box-sizing: border-box;
        }
        
        .game-container::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 10px;
            background: #0D1117;
        }
        
        .piece {
            position: absolute;
            background: #484f58;
            border: 2px solid #6e7681;
            border-radius: 4px;
            cursor: grab;
            user-select: none;
            will-change: transform;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }
        
        .piece:hover {
            background: #56606a;
            border-color: #8b949e;
        }
        
        .piece:active {
            cursor: grabbing;
        }
        
        .piece.dragging {
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }
        
        .target {
            background: #7c8998 !important;
            border-color: #a6adb6 !important;
        }
        
        .target:hover {
            background: #8b949e !important;
            border-color: #b1b8c0 !important;
        }
        
        .timer {
            position: absolute;
            top: -60px;
            right: 10px;
            color: #ff4444;
            font-family: 'DSEG7Modern', 'Courier New', monospace;
            font-size: 32px;
            font-weight: bold;
            text-shadow: 0 0 12px rgba(255, 68, 68, 0.6);
            letter-spacing: 3px;
            background: rgba(13, 17, 23, 0.8);
            padding: 8px 12px;
            border-radius: 6px;
            border: 2px solid #30363d;
        }
        
        .timer-left {
            position: absolute;
            top: -60px;
            left: 10px;
            color: #00d7ff;
            font-family: 'DSEG7Modern', 'Courier New', monospace;
            font-size: 32px;
            font-weight: bold;
            text-shadow: 0 0 12px rgba(0, 215, 255, 0.6);
            letter-spacing: 3px;
            background: rgba(13, 17, 23, 0.8);
            padding: 8px 12px;
            border-radius: 6px;
            border: 2px solid #30363d;
        }
        
        .win-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(13, 17, 23, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        
        .win-message {
            background: #21262d;
            color: #f0f6fc;
            padding: 40px;
            border-radius: 12px;
            text-align: center;
            font-size: 24px;
            font-weight: 600;
            box-shadow: 0 16px 32px rgba(0, 0, 0, 0.6);
            border: 1px solid #30363d;
            transform: scale(0);
            transition: transform 0.3s ease;
        }
        
        .win-time {
            font-family: 'DSEG7Modern', 'Courier New', monospace;
            color: #ff4444;
            font-size: 22px;
            margin-top: 20px;
            text-shadow: 0 0 8px rgba(255, 68, 68, 0.4);
            letter-spacing: 2px;
        }
        
        .win-moves {
            font-family: 'DSEG7Modern', 'Courier New', monospace;
            color: #00d7ff;
            font-size: 22px;
            margin-top: 10px;
            text-shadow: 0 0 8px rgba(0, 215, 255, 0.4);
            letter-spacing: 2px;
        }
        
        .win-overlay.show {
            display: flex;
        }
        
        .win-overlay.show .win-message {
            transform: scale(1);
        }
    </style>
</head>
<body>
    <div class="game-container" id="gameContainer">
        <div class="timer-left" id="timerLeft">000</div>
        <div class="timer" id="timer">000</div>
        <!-- Pieces will be dynamically created -->
    </div>
    
    <div class="win-overlay" id="winOverlay">
        <div class="win-message">
            Puzzle Solved<br>
            <div class="win-moves" id="winMoves">000</div>
            <div class="win-time" id="winTime">000</div>
        </div>
    </div>

    <script>
        class KlotskiGame {
            constructor() {
                this.container = document.getElementById('gameContainer');
                this.timerDisplay = document.getElementById('timer');
                this.timerLeftDisplay = document.getElementById('timerLeft');
                this.gridSize = 100; // Each cell is 100px (increased from 80px)
                this.pieces = [];
                this.draggedPiece = null;
                this.startPos = { x: 0, y: 0 };
                this.dragOffset = { x: 0, y: 0 };
                this.isDragging = false;
                
                // Timer variables
                this.startTime = null;
                this.timerInterval = null;
                this.currentSeconds = 0;
                this.gameStarted = false;
                
                // Moves counter
                this.moves = 0;
                
                this.initializePieces();
                this.setupEventListeners();
                this.updateMovesDisplay(); // Initialize moves display
            }
            
            isValidMove(piece, fromX, fromY, toX, toY) {
                // First check if destination is valid
                if (!this.isValidPosition(piece, toX, toY)) {
                    return false;
                }
                
                // Check if path is clear (can't jump over pieces)
                if (fromX === toX) {
                    // Vertical movement
                    const startY = Math.min(fromY, toY);
                    const endY = Math.max(fromY, toY);
                    
                    for (let y = startY; y <= endY; y++) {
                        for (let x = fromX; x < fromX + piece.pieceData.width; x++) {
                            // Skip checking the piece's original position
                            if (y >= fromY && y < fromY + piece.pieceData.height && 
                                x >= fromX && x < fromX + piece.pieceData.width) {
                                continue;
                            }
                            
                            if (this.isOccupied(x, y, piece)) {
                                return false;
                            }
                        }
                    }
                } else if (fromY === toY) {
                    // Horizontal movement
                    const startX = Math.min(fromX, toX);
                    const endX = Math.max(fromX, toX);
                    
                    for (let x = startX; x <= endX; x++) {
                        for (let y = fromY; y < fromY + piece.pieceData.height; y++) {
                            // Skip checking the piece's original position
                            if (x >= fromX && x < fromX + piece.pieceData.width && 
                                y >= fromY && y < fromY + piece.pieceData.height) {
                                continue;
                            }
                            
                            if (this.isOccupied(x, y, piece)) {
                                return false;
                            }
                        }
                    }
                } else {
                    // Diagonal movement not allowed in Klotski
                    return false;
                }
                
                return true;
            }
            
            isOccupied(x, y, excludePiece) {
                for (let piece of this.pieces) {
                    if (piece === excludePiece) continue;
                    
                    const px = piece.pieceData.x;
                    const py = piece.pieceData.y;
                    const pw = piece.pieceData.width;
                    const ph = piece.pieceData.height;
                    
                    if (x >= px && x < px + pw && y >= py && y < py + ph) {
                        return true;
                    }
                }
                return false;
            }
            
            initializePieces() {
                // Classic Klotski setup
                const pieceConfigs = [
                    // Target piece (2x2) - the one that needs to reach the bottom
                    { id: 'target', width: 2, height: 2, x: 1, y: 0, class: 'target' },
                    
                    // Vertical pieces (1x2)
                    { id: 'v1', width: 1, height: 2, x: 0, y: 0, class: 'piece' },
                    { id: 'v2', width: 1, height: 2, x: 3, y: 0, class: 'piece' },
                    { id: 'v3', width: 1, height: 2, x: 0, y: 2, class: 'piece' },
                    { id: 'v4', width: 1, height: 2, x: 3, y: 2, class: 'piece' },
                    
                    // Horizontal pieces (2x1)
                    { id: 'h1', width: 2, height: 1, x: 1, y: 2, class: 'piece' },
                    
                    // Small pieces (1x1)
                    { id: 's1', width: 1, height: 1, x: 1, y: 3, class: 'piece' },
                    { id: 's2', width: 1, height: 1, x: 2, y: 3, class: 'piece' },
                    { id: 's3', width: 1, height: 1, x: 0, y: 4, class: 'piece' },
                    { id: 's4', width: 1, height: 1, x: 3, y: 4, class: 'piece' }
                ];
                
                pieceConfigs.forEach(config => {
                    this.createPiece(config);
                });
            }
            
            createPiece(config) {
                const piece = document.createElement('div');
                piece.className = `piece ${config.class}`;
                piece.id = config.id;
                
                const gapSize = 4; // 4px gap on each side  
                const width = (config.width * this.gridSize) - (gapSize * 2);
                const height = (config.height * this.gridSize) - (gapSize * 2);
                
                piece.style.width = width + 'px';
                piece.style.height = height + 'px';
                piece.style.left = (config.x * this.gridSize + gapSize) + 'px';
                piece.style.top = (config.y * this.gridSize + gapSize) + 'px';
                
                piece.pieceData = {
                    width: config.width,
                    height: config.height,
                    x: config.x,
                    y: config.y
                };
                
                this.container.appendChild(piece);
                this.pieces.push(piece);
            }
            
            setupEventListeners() {
                this.pieces.forEach(piece => {
                    piece.addEventListener('mousedown', (e) => this.startDrag(e, piece));
                    piece.addEventListener('touchstart', (e) => this.startDrag(e, piece));
                });
                
                document.addEventListener('mousemove', (e) => this.drag(e));
                document.addEventListener('touchmove', (e) => this.drag(e));
                
                document.addEventListener('mouseup', (e) => this.endDrag(e));
                document.addEventListener('touchend', (e) => this.endDrag(e));
            }
            
            startDrag(e, piece) {
                e.preventDefault();
                
                // Start timer on first move
                if (!this.gameStarted) {
                    this.startTimer();
                    this.gameStarted = true;
                }
                
                this.draggedPiece = piece;
                this.isDragging = true;
                piece.classList.add('dragging');
                
                const rect = this.container.getBoundingClientRect();
                const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
                const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;
                
                this.startPos = {
                    x: piece.pieceData.x,
                    y: piece.pieceData.y
                };
                
                // Calculate offset from piece center
                const pieceRect = piece.getBoundingClientRect();
                this.dragOffset = {
                    x: clientX - pieceRect.left - pieceRect.width / 2,
                    y: clientY - pieceRect.top - pieceRect.height / 2
                };
            }
            
            drag(e) {
                if (!this.isDragging || !this.draggedPiece) return;
                e.preventDefault();
                
                const rect = this.container.getBoundingClientRect();
                const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
                const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;
                
                const gapSize = 4;
                // Calculate position relative to container
                const x = clientX - rect.left - this.dragOffset.x - (this.draggedPiece.offsetWidth / 2);
                const y = clientY - rect.top - this.dragOffset.y - (this.draggedPiece.offsetHeight / 2);
                
                // Use transform for smooth, hardware-accelerated movement
                const baseX = this.startPos.x * this.gridSize + gapSize;
                const baseY = this.startPos.y * this.gridSize + gapSize;
                this.draggedPiece.style.transform = `translate(${x - baseX}px, ${y - baseY}px)`;
            }
            
            endDrag(e) {
                if (!this.isDragging || !this.draggedPiece) return;
                
                const piece = this.draggedPiece;
                piece.classList.remove('dragging');
                this.isDragging = false;
                
                // Get current position
                const rect = piece.getBoundingClientRect();
                const containerRect = this.container.getBoundingClientRect();
                
                // Calculate grid position from center of piece
                const centerX = rect.left + rect.width / 2 - containerRect.left;
                const centerY = rect.top + rect.height / 2 - containerRect.top;
                
                let targetX = Math.round((centerX - piece.offsetWidth / 2) / this.gridSize);
                let targetY = Math.round((centerY - piece.offsetHeight / 2) / this.gridSize);
                
                // Clamp to boundaries
                targetX = Math.max(0, Math.min(4 - piece.pieceData.width, targetX));
                targetY = Math.max(0, Math.min(5 - piece.pieceData.height, targetY));
                
                // Check if position is valid and path is clear
                if (this.isValidMove(piece, this.startPos.x, this.startPos.y, targetX, targetY)) {
                    // Only count as a move if the piece actually changed position
                    if (targetX !== this.startPos.x || targetY !== this.startPos.y) {
                        this.moves++;
                        this.updateMovesDisplay();
                    }
                    
                    // Update piece position
                    piece.pieceData.x = targetX;
                    piece.pieceData.y = targetY;
                    
                    // Reset transform and update position with gaps
                    const gapSize = 4;
                    piece.style.transform = '';
                    piece.style.left = (targetX * this.gridSize + gapSize) + 'px';
                    piece.style.top = (targetY * this.gridSize + gapSize) + 'px';
                    
                    this.checkWin();
                } else {
                    // Reset to original position with gaps
                    const gapSize = 4;
                    piece.style.transform = '';
                    piece.style.left = (this.startPos.x * this.gridSize + gapSize) + 'px';
                    piece.style.top = (this.startPos.y * this.gridSize + gapSize) + 'px';
                }
                
                this.draggedPiece = null;
            }
            
            isValidPosition(piece, x, y) {
                // Check boundaries
                if (x < 0 || y < 0 || x + piece.pieceData.width > 4 || y + piece.pieceData.height > 5) {
                    return false;
                }
                
                // Check collision with other pieces
                for (let otherPiece of this.pieces) {
                    if (otherPiece === piece) continue;
                    
                    const otherX = otherPiece.pieceData.x;
                    const otherY = otherPiece.pieceData.y;
                    const otherW = otherPiece.pieceData.width;
                    const otherH = otherPiece.pieceData.height;
                    
                    // Check overlap
                    if (x < otherX + otherW && x + piece.pieceData.width > otherX &&
                        y < otherY + otherH && y + piece.pieceData.height > otherY) {
                        return false;
                    }
                }
                
                return true;
            }
            
            checkWin() {
                const targetPiece = document.getElementById('target');
                if (targetPiece && targetPiece.pieceData.x === 1 && targetPiece.pieceData.y === 3) {
                    // Stop timer
                    this.stopTimer();
                    
                    setTimeout(() => {
                        const winOverlay = document.getElementById('winOverlay');
                        const winTimeDisplay = document.getElementById('winTime');
                        const winMovesDisplay = document.getElementById('winMoves');
                        
                        winTimeDisplay.textContent = this.formatTime(this.currentSeconds);
                        winMovesDisplay.textContent = this.formatTime(this.moves);
                        winOverlay.classList.add('show');
                        
                        // Hide overlay when clicked
                        winOverlay.addEventListener('click', () => {
                            winOverlay.classList.remove('show');
                        });
                    }, 300);
                }
            }
            
            startTimer() {
                this.startTime = Date.now();
                this.timerInterval = setInterval(() => {
                    this.currentSeconds = Math.floor((Date.now() - this.startTime) / 1000);
                    this.updateTimerDisplay();
                }, 100); // Update every 100ms for smooth counting
            }
            
            stopTimer() {
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                    this.timerInterval = null;
                }
            }
            
            updateTimerDisplay() {
                this.timerDisplay.textContent = this.formatTime(this.currentSeconds);
            }
            
            updateMovesDisplay() {
                this.timerLeftDisplay.textContent = this.formatTime(this.moves);
            }
            
            formatTime(seconds) {
                // Format as 3-digit number (000-999)
                return Math.min(999, seconds).toString().padStart(3, '0');
            }
        }
        
        // Initialize game when page loads
        window.addEventListener('DOMContentLoaded', () => {
            new KlotskiGame();
        });
    </script>
</body>
</html>