<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>PS2 Scene</title>
	<style>
		body {
			margin: 0;
			padding: 0;
			overflow: hidden;
			background: black;
			font-family: 'Roboto', sans-serif;
		}
		
		#container {
			position: relative;
			width: 100vw;
			height: 100vh;
		}
		
		#fade {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background: black;
			opacity: 1;
			pointer-events: none;
			z-index: 2;
		}
		
		#text {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			display: flex;
			align-items: center;
			justify-content: center;
			font-weight: bold;
			font-size: 2.5rem;
			color: white;
			text-shadow: 2px 2px 0px black, -2px -2px 0px black, 2px -2px 0px black, -2px 2px 0px black;
			opacity: 0;
			pointer-events: none;
			z-index: 3;
		}
	</style>
	<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
	<div id="container">
		<div id="fade"></div>
		<div id="text">PS2 INTRO</div>
	</div>

	<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
	<script>
		let scene, camera, renderer, orbs, cubes, fogPlane, frameId;
		let fadeElement, textElement;
		let startTime;

		function init() {
			// Get DOM elements
			fadeElement = document.getElementById('fade');
			textElement = document.getElementById('text');
			
			// Scene setup
			scene = new THREE.Scene();
			scene.background = new THREE.Color(0x000000);

			// Camera setup
			camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
			camera.position.set(0, 20, 0);
			camera.lookAt(0, 0, 0);

			// Renderer setup
			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.shadowMap.enabled = true;
			renderer.shadowMap.type = THREE.PCFSoftShadowMap;
			
			document.getElementById('container').appendChild(renderer.domElement);

			// Pillars
			const pillarMaterial = new THREE.MeshLambertMaterial({ color: 0x808080 });
			for(let x = -5; x <= 5; x++) {
				for(let z = -5; z <= 5; z++) {
					if(Math.random() > 0.5) {
						const h = Math.random() * 7;
						const pillar = new THREE.Mesh(
							new THREE.BoxGeometry(0.8, h, 0.8),
							pillarMaterial
						);
						pillar.position.set(x, h/2, z);
						scene.add(pillar);
					}
				}
			}

			// 4 Orbs
			const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xff00ff];
			orbs = [];
			colors.forEach((color, i) => {
				const orb = new THREE.Mesh(
					new THREE.SphereGeometry(0.05, 16, 16), 
					new THREE.MeshBasicMaterial({ color })
				);
				orbs.push(orb);
				scene.add(orb);
			});

			// 3 Rotating cubes
			const cubeMaterial = new THREE.MeshStandardMaterial({ 
				color: 0x333333,
				transparent: true, 
				opacity: 0.4,
				roughness: 0.1,
				metalness: 0.2
			});
			cubes = [];
			const cubePositions = [
				{ x: -3, y: 7.5, z: 2 },
				{ x: 4, y: 8.2, z: -1 },
				{ x: -1, y: 8.8, z: -4 }
			];
			
			cubePositions.forEach((pos, i) => {
				const cube = new THREE.Mesh(
					new THREE.BoxGeometry(0.8, 0.8, 0.8),
					cubeMaterial
				);
				cube.position.set(pos.x, pos.y, pos.z);
				cubes.push(cube);
				scene.add(cube);
			});

			// Fog plane with moving noise
			const canvas = document.createElement('canvas');
			canvas.width = 128;
			canvas.height = 128;
			const ctx = canvas.getContext('2d');
			
			// Create noise pattern
			const imageData = ctx.createImageData(128, 128);
			for (let i = 0; i < imageData.data.length; i += 4) {
				const noise = Math.random() * 255;
				imageData.data[i] = noise;     // R
				imageData.data[i + 1] = noise; // G  
				imageData.data[i + 2] = noise; // B
				imageData.data[i + 3] = 100;   // A
			}
			ctx.putImageData(imageData, 0, 0);
			
			const fogTexture = new THREE.CanvasTexture(canvas);
			fogTexture.wrapS = THREE.RepeatWrapping;
			fogTexture.wrapT = THREE.RepeatWrapping;
			fogTexture.repeat.set(4, 4);
			
			const fogGeometry = new THREE.PlaneGeometry(20, 20);
			const fogMaterial = new THREE.MeshBasicMaterial({
				map: fogTexture,
				transparent: true,
				opacity: 0.4,
				side: THREE.DoubleSide
			});
			
			fogPlane = new THREE.Mesh(fogGeometry, fogMaterial);
			fogPlane.rotation.x = -Math.PI / 2; // horizontal
			fogPlane.position.y = 0.1; // just above ground
			scene.add(fogPlane);

			// Lighting
			const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
			scene.add(ambientLight);
			
			const pointLight = new THREE.PointLight(0xffffff, 1, 100);
			pointLight.position.set(0, 20, 0);
			scene.add(pointLight);

			// Start time
			startTime = Date.now();

			// Handle resize
			window.addEventListener('resize', onWindowResize);
			
			// Start animation
			animate();
		}

		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize(window.innerWidth, window.innerHeight);
		}

		function animate() {
			frameId = requestAnimationFrame(animate);
			
			const elapsed = (Date.now() - startTime) * 0.001; // seconds
			const t = elapsed % 10; // loop every 10 seconds

			// Camera animation - stay above center, descend and rotate
			camera.position.set(0, 20 - (t/10) * 5, 0); // 20 to 15 over 10s
			camera.lookAt(0, 0, 0); // point down first
			
			// Clear acceleration at halfway: slow then very fast rotation
			let rotation;
			if (t <= 7.5) {
				// -10deg to 10deg over 7.5s (very slow - only 20 degrees)
				rotation = -Math.PI/18 + (t/7.5) * (20 * Math.PI/180);
			} else {
				// 10deg to 90deg over 2.5s (very fast - 80 degrees in 2.5s)
				rotation = (10 * Math.PI/180) + ((t-7.5)/2.5) * (80 * Math.PI/180);
			}
			camera.rotation.z = rotation;

			// Orbs figure-8 motion
			orbs.forEach((orb, i) => {
				const phase = t * 0.5 + i * Math.PI/2; // offset each orb
				orb.position.x = 4 * Math.sin(phase);
				orb.position.z = 2 * Math.sin(2 * phase);
				orb.position.y = 8;
			});

			// Rotating cubes
			cubes.forEach((cube, i) => {
				cube.rotation.x = t * 0.8 + i;
				cube.rotation.y = t * 1.2 + i * 0.5;
				cube.rotation.z = t * 0.6 + i * 0.3;
			});

			// Moving fog texture
			fogPlane.material.map.offset.x = t * 0.1;

			// Fade overlay and text control
			let opacity = 0;
			if (t < 0.5) {
				// Fade out from black in first 0.5s
				opacity = 1 - (t / 0.5);
			} else if (t > 9) {
				// Fade to black in last 1s
				opacity = (t - 9) / 1;
			}
			fadeElement.style.opacity = opacity;

			// Text fade control
			let textOpacity = 0;
			if (t >= 1 && t <= 4) {
				// Fade in from 1s to 1.5s, fade out from 3.5s to 4s
				if (t <= 1.5) {
					textOpacity = (t - 1) / 0.5; // fade in over 0.5s
				} else if (t >= 3.5) {
					textOpacity = 1 - ((t - 3.5) / 0.5); // fade out over 0.5s
				} else {
					textOpacity = 1; // fully visible between 1.5s and 3.5s
				}
			}
			textElement.style.opacity = textOpacity;
			
			renderer.render(scene, camera);
		}

		function cleanup() {
			if (frameId) {
				cancelAnimationFrame(frameId);
			}
			window.removeEventListener('resize', onWindowResize);
			
			if (renderer) {
				renderer.dispose();
			}
			if (scene) {
				scene.clear();
			}
		}

		// Start when page loads
		window.addEventListener('load', init);
		window.addEventListener('beforeunload', cleanup);
	</script>
</body>
</html>