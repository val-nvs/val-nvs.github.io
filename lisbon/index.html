<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
	<title>lisbon subway entrances</title>
	
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
	
	<link
		rel="stylesheet"
		href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
	/>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Playwrite+CU:wght@400&display=swap" rel="stylesheet">
    
	<style>
		html, body {
			background: #000;
			height: 100%;
			width: 100%;
			margin: 0;
			padding: 0;
		}
		#map { height: 100%; width: 100%; }
		/* Custom style for the location button icon */
		.leaflet-control-locate {
			background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="black"><path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/></svg>');
			background-size: 20px 20px;
			background-repeat: no-repeat;
			background-position: center;
			cursor: pointer;
		}
		.leaflet-control-locate:hover {
			background-color: #f4f4f4;
		}
        
        /* Custom CSS for the station labels (Tooltips) */
        .leaflet-tooltip.station-label {
            /* Playwrite CU font and properties */
            font-family: "Playwrite CU", cursive;
            font-optical-sizing: auto;
            font-weight: 400; 
            font-style: normal;
            
            background-color: transparent;
            border: none;
            box-shadow: none;
            /* Removed fixed font-size: 12px; to be set dynamically by JS */
            color: #ffffff;
            padding: 2px 4px;
            white-space: nowrap;
            text-shadow: 1px 1px 2px #000;
            transition: font-size 0.3s ease-out; /* Optional: smooth transition for font size change */
        }
        
        /* Remove the tooltip arrow/stem */
        .leaflet-tooltip-bottom.no-arrow::before {
            border-bottom-color: transparent !important;
        }
        .leaflet-tooltip.no-arrow::before {
            display: none !important;
        }
	</style>
</head>

<body>
<div id="map"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
const map = L.map('map').setView([38.715, -9.138], 16);

// ------------------------------------------------------------------
// 1. MAP STYLE SWITCHER (TOP RIGHT)
// ------------------------------------------------------------------

// Define the tile layers
const positron = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
    attribution: '&copy; <a href="https://www.openstreetmap.org/">OSM</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
    subdomains: 'abcd',
    maxZoom: 20
});

const darkMatter = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
    attribution: '&copy; <a href="https://www.openstreetmap.org/">OSM</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
    subdomains: 'abcd',
    maxZoom: 20
}).addTo(map); // Added by default

const voyager = L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', {
    attribution: '&copy; <a href="https://www.openstreetmap.org/">OSM</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
    subdomains: 'abcd',
    maxZoom: 20
});

const baseMaps = {
    "Dark Matter (Dark)": darkMatter,
    "Positron (Light)": positron,
    "Voyager (Color)": voyager
};

// Add the Layer Control to the map (defaults to top right)
L.control.layers(baseMaps).addTo(map);


// ------------------------------------------------------------------
// 2. USER LOCATION LOGIC & UPDATE BUTTON (BOTTOM LEFT)
// ------------------------------------------------------------------

// Variables to hold user location visualization elements
let userMarker = null;
let userCircle = null;

// Function to run when location is found
function onLocationFound(e) {
    const radius = e.accuracy / 2;

    // Clear existing marker and circle if they exist
    if (userMarker) {
        map.removeLayer(userMarker);
    }
    if (userCircle) {
        map.removeLayer(userCircle);
    }

    // Add new marker (pin)
    userMarker = L.marker(e.latlng).addTo(map)
        .bindPopup("You are within " + radius.toFixed(0) + " meters of this point");

    // Add new circle (accuracy)
    userCircle = L.circle(e.latlng, radius, {
        color: '#1a75ff',
        fillColor: '#1a75ff',
        fillOpacity: 0.2,
        weight: 1
    }).addTo(map);
    
    // Open the popup, but DO NOT call map.setView() to keep the current map center
    userMarker.openPopup();
}

// Function to run if location access fails
function onLocationError(e) {
    console.error("Location error:", e.message);
    alert("Could not find your location. Please ensure location services are enabled.");
}

// Define the function that starts the location process
function locateUser() {
    // setView: false ensures the map does not automatically pan/zoom
    map.locate({setView: false, maxZoom: 16});
}

// Set up event listeners for location success and failure
map.on('locationfound', onLocationFound);
map.on('locationerror', onLocationError);

// Create a custom control for the 'Update Location' button
L.Control.LocationButton = L.Control.extend({
    options: {
        position: 'bottomleft' // Place the button in the bottom left
    },

    onAdd: function (map) {
        const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control leaflet-control-custom leaflet-control-locate');
        container.style.backgroundColor = 'white';
        container.style.width = '30px';
        container.style.height = '30px';
        container.title = 'Update Location';

        container.onclick = locateUser; // Assign the click action

        // Prevent click events from propagating to the map
        L.DomEvent.disableClickPropagation(container);
        
        return container;
    }
});

// Add the control to the map
L.control.locationButton = function(opts) {
    return new L.Control.LocationButton(opts);
}
L.control.locationButton().addTo(map);

// NOTE: The automatic call to locateUser() on page load has been removed.
// Location fetching now relies only on the user clicking the button.


// ------------------------------------------------------------------
// 3. EXISTING SUBWAY DATA CODE (MODIFIED FOR LABELS)
// ------------------------------------------------------------------

// Create a dedicated pane for subway entrances
map.createPane('subwayEntrances');
map.getPane('subwayEntrances').style.zIndex = 650;

// Metro line colors
const lineColors = {
	'red': 'rgba(238, 43, 115, 0.2)',
	'blue': 'rgba(84, 136, 197, 0.2)',
	'yellow': 'rgba(253, 183, 19, 0.2)',
	'green': 'rgba(0, 168, 165, 0.2)'
};

// Function to calculate and apply font size based on zoom level
// Base zoom is 16 (where we want 12px)
// Size increases by 2px for every zoom level above 16
function updateLabelFontSize() {
    const currentZoom = map.getZoom();
    const baseZoom = 16;
    const baseSize = 12; // Starting font size at base zoom
    
    // Simple linear scaling: +2px for every zoom level increase
    const newSize = Math.max(baseSize, baseSize + (currentZoom - baseZoom) * 2);
    
    // Select all tooltip elements with the 'station-label' class
    const labels = document.querySelectorAll('.leaflet-tooltip.station-label');
    
    labels.forEach(label => {
        // Apply the new font size directly as an inline style
        label.style.fontSize = `${newSize}px`;
    });
}


// Overpass query
const query = `
[out:json][timeout:60];

// --- Step 1: fetch ALL subway entrances in Lisbon area
node["railway"="subway_entrance"](38.6,-9.3,38.9,-9.0)->.entrances;

// --- Step 2: fetch ALL subway stations with station=subway tag
(
  node["railway"="station"]["station"="subway"](38.6,-9.3,38.9,-9.0);
  way["railway"="station"]["station"="subway"](38.6,-9.3,38.9,-9.0);
  relation["railway"="station"]["station"="subway"](38.6,-9.3,38.9,-9.0);
)->.stations;

// --- Step 3: fetch ALL metro line relations
relation["type"="route"]["route"="subway"](38.6,-9.3,38.9,-9.0)->.lines;

// --- Step 4: combine everything
(.entrances; .stations; .lines;);
out geom;
>;
out skel qt;
`;

fetch('https://overpass-api.de/api/interpreter', {
	method: 'POST',
	body: query
})
.then(res => res.json())
.then(data => {
	// FIRST PASS: Load only MAGENTA dots (subway entrances)
	const magentas = data.elements.filter(el => 
		el.type === "node" && el.lat && el.lon && el.tags?.railway === "subway_entrance"
	);
	
	magentas.forEach(el => {
		L.circleMarker([el.lat, el.lon], {
			radius: 10,
			fillColor: '#ff00ff',
			color: '#000',
			weight: 1,
			opacity: 1,
			fillOpacity: 0.6,
			pane: 'subwayEntrances'
		}).addTo(map)
		.bindPopup(el.tags?.name || el.id);
	});

	// SECOND PASS: Load everything else after magenta dots are done
	setTimeout(() => {
		data.elements.forEach(el => {
			// dots (subway stations)
			if(el.type === "node" && el.lat && el.lon && el.tags?.station === "subway") {
                const stationName = el.tags?.name; // Get the station name
                
				let fillColor = '#000000';
				if(el.tags?.line) {
					fillColor = lineColors[el.tags.line] || fillColor;
				}
				
				const marker = L.circleMarker([el.lat, el.lon], {
					radius: 6,
					fillColor,
					color: '#000',
					weight: 1,
					opacity: 1,
					fillOpacity: 0.6,
					pane: 'subwayEntrances'
				}).addTo(map)
				.bindPopup(stationName || el.id); // Keep the popup functionality
                
                // Add permanent tooltip if a name exists
                if (stationName) {
                    marker.bindTooltip(stationName, {
                        permanent: true,
                        direction: 'bottom',
                        offset: [0, 8],
                        className: 'station-label no-arrow' // Custom class for styling and no arrow
                    });
                }
			}
		});

		// Ways (station shapes and lines)
		data.elements.forEach(el => {
			if(el.type === "way" && el.geometry) {
				let color = 'rgba(255,255,255,0.5)';
				let weight = 3;
				let opacity = 0.5;
                const stationName = el.tags?.name; // Get name for Way

				if(el.tags?.station === "subway") {
					color = 'rgba(255,255,255,0.5)';
					weight = 4;
					opacity = 0.7;
				} else if(el.tags?.line) {
					color = lineColors[el.tags.line] || color;
				}

				const latlngs = el.geometry.map(p => [p.lat, p.lon]);
				const polyline = L.polyline(latlngs, {
					color,
					weight,
					opacity
				}).addTo(map)
				.bindPopup(stationName || el.id);
                
                // Add permanent tooltip if it's a station and a name exists
                if (el.tags?.station === "subway" && stationName) {
                    polyline.bindTooltip(stationName, {
                        permanent: true,
                        direction: 'center', // Center the label on the polyline/shape
                        className: 'station-label no-arrow',
                        interactive: false
                    });
                }
			}
		});

		// Relations (metro lines) - Check members for station names
		data.elements.forEach(el => {
			if(el.type === "relation" && el.members) {
				const relationName = el.tags?.name || el.tags?.ref; // Use relation name
				
				el.members.forEach(m => {
					if(m.type === "way" && m.geometry) {
						let color = 'rgba(255,255,255,0.5)';
						let weight = 2;
						let opacity = 0.7;

						if(el.tags?.colour) {
							color = el.tags.colour;
							weight = 3;
							opacity = 0.8;
						} else if(el.tags?.station === "subway") {
							color = '#ffffff';
							weight = 3;
							opacity = 0.8;
						} else if(el.tags?.line) {
							color = lineColors[el.tags.line] || color;
						}

						const latlngs = m.geometry.map(p => [p.lat, p.lon]);
						const polyline = L.polyline(latlngs, {
							color,
							weight,
							opacity
						}).addTo(map)
						.bindPopup(relationName || el.id);

						// Add permanent tooltip if a name exists (for the line/relation itself)
						// We only label the first segment of the relation to avoid clutter
						if (relationName && m === el.members[0]) {
							polyline.bindTooltip(relationName, {
								permanent: true,
								direction: 'center',
								className: 'station-label no-arrow',
								interactive: false
							});
						}
					}
				});
			}
		});
        
        // Initial application of the font size
        updateLabelFontSize();
        
        // Add event listener to update font size on zoom
        map.on('zoomend', updateLabelFontSize);

	}, 100);
});
</script>
</body>
</html>